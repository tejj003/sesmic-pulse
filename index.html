<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Seismic Pulse - Interactive Earthquake Data Art</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #0c0c0c 0%, #1a1a1e 50%, #16213e 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            height: 100vh;
            color: white;
        }

        .container {
            position: relative;
            width: 100%;
            height: 100vh;
        }

        .title {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            text-align: center;
            color: #fff;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
        }

        .title h1 {
            font-size: 2.5rem;
            font-weight: 300;
            letter-spacing: 3px;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .title p {
            font-size: 1rem;
            opacity: 0.8;
            font-weight: 300;
        }

        #visualization {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
        }

        .controls {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            z-index: 100;
        }

        .control-btn {
            padding: 12px 24px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 25px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            font-size: 14px;
            font-weight: 500;
        }

        .control-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(255, 255, 255, 0.1);
        }

        .control-btn.active {
            background: rgba(78, 205, 196, 0.3);
            border-color: #4ecdc4;
            box-shadow: 0 0 20px rgba(78, 205, 196, 0.3);
        }

        .info-panel {
            position: absolute;
            top: 50%;
            left: 30px;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            max-width: 300px;
            z-index: 50;
        }

        .info-panel h3 {
            color: #4ecdc4;
            margin-bottom: 15px;
            font-size: 1.2rem;
        }

        .info-item {
            margin-bottom: 10px;
            font-size: 0.9rem;
            line-height: 1.4;
        }

        .magnitude-legend {
            position: absolute;
            top: 50%;
            right: 30px;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 50;
        }

        .magnitude-legend h4 {
            color: #ff6b6b;
            margin-bottom: 15px;
            font-size: 1.1rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            font-size: 0.85rem;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-right: 10px;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 200;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top: 3px solid #4ecdc4;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .pulse {
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.7; }
            100% { transform: scale(1); opacity: 1; }
        }

        .ripple {
            animation: ripple 3s infinite;
        }

        @keyframes ripple {
            0% { transform: scale(1); opacity: 0.8; }
            100% { transform: scale(3); opacity: 0; }
        }

        /* Custom roundRect function for better tooltip corners */
        CanvasRenderingContext2D.prototype.roundRect = function(x, y, width, height, radius) {
            this.beginPath();
            this.moveTo(x + radius, y);
            this.lineTo(x + width - radius, y);
            this.quadraticCurveTo(x + width, y, x + width, y + radius);
            this.lineTo(x + width, y + height - radius);
            this.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            this.lineTo(x + radius, y + height);
            this.quadraticCurveTo(x, y + height, x, y + height - radius);
            this.lineTo(x, y + radius);
            this.quadraticCurveTo(x, y, x + radius, y);
            this.closePath();
            return this;
        };

        /* Tooltip styles */
        #earthquake-tooltip {
            position: absolute;
            display: none;
            background-color: black;
            color: white;
            padding: 12px;
            border-radius: 6px;
            z-index: 1000;
            width: 220px;
            box-shadow: 0 0 15px rgba(0,0,0,0.8);
            pointer-events: none;
            border: 2px solid #FFD700;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        #earthquake-tooltip .magnitude {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 8px;
        }
        
        #earthquake-tooltip .detail {
            font-size: 13px;
            margin-bottom: 5px;
            color: #eee;
        }
        
        #earthquake-tooltip .time {
            font-size: 12px;
            color: #ccc;
            margin-top: 8px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="title">
            <h1>SEISMIC PULSE</h1>
            <p>Real-time Global Earthquake Data Visualization</p>
        </div>

        <div class="loading" id="loading">
            <div class="spinner"></div>
            <p>Loading earthquake data...</p>
        </div>

        <canvas id="visualization"></canvas>

        <div class="info-panel">
            <h3>Live Statistics</h3>
            <div class="info-item">Total Earthquakes: <span id="totalCount">0</span></div>
            <div class="info-item">Strongest Today: <span id="strongestMag">0.0</span></div>
            <div class="info-item">Latest Location: <span id="latestLocation">Loading...</span></div>
            <div class="info-item">Data Updated: <span id="lastUpdate">Never</span></div>
        </div>

        <div class="magnitude-legend">
            <h4>Magnitude Scale</h4>
            <div class="legend-item">
                <div class="legend-color" style="background: #90EE90;"></div>
                <span>0.0 - 2.5 (Minor)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #FFD700;"></div>
                <span>2.5 - 4.5 (Light)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #FFA500;"></div>
                <span>4.5 - 6.0 (Moderate)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #FF6347;"></div>
                <span>6.0 - 7.0 (Strong)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #FF0000;"></div>
                <span>7.0+ (Major)</span>
            </div>
        </div>

        <div class="controls">
            <button class="control-btn active" onclick="setVisualizationMode('artistic')">Artistic Mode</button>
            <button class="control-btn" onclick="setVisualizationMode('geographic')">Geographic Mode</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('visualization');
        const ctx = canvas.getContext('2d');
        const loading = document.getElementById('loading');
        
        let earthquakes = [];
        let currentMode = 'artistic';
        let animationId;
        let particles = [];
        let time = 0;
        let mouseX = 0;
        let mouseY = 0;
        let hoveredEarthquake = null;

        // Canvas setup
        function resizeCanvas() {
            // Get device pixel ratio for sharp rendering
            const dpr = window.devicePixelRatio || 1;
            
            // Set display size (css pixels)
            const displayWidth = window.innerWidth;
            const displayHeight = window.innerHeight;
            
            // Set actual size in memory (scaled up for retina displays)
            canvas.width = displayWidth * dpr;
            canvas.height = displayHeight * dpr;
            
            // Scale the canvas back down using CSS
            canvas.style.width = displayWidth + 'px';
            canvas.style.height = displayHeight + 'px';
            
            // Scale the drawing context to ensure correct drawing operations
            ctx.scale(dpr, dpr);
            
            // Set better rendering quality
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Add mouse move listener
        canvas.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });

        // Particle system for artistic effects
        class Particle {
            constructor(x, y, magnitude) {
                this.x = x;
                this.y = y;
                this.magnitude = magnitude;
                this.size = Math.random() * 3 + 1;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                this.life = 1;
                this.decay = Math.random() * 0.02 + 0.01;
                this.color = getMagnitudeColor(magnitude);
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= this.decay;
                this.size *= 0.995;
            }

            draw() {
                if (this.life <= 0) return;
                
                ctx.save();
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        // Fetch earthquake data from USGS API
        async function fetchEarthquakeData() {
            try {
                // Show loading
                loading.style.display = 'block';
                
                // Try to fetch live data with timeout
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout
                
                const response = await fetch('https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all_day.geojson', {
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                
                if (!data.features || data.features.length === 0) {
                    throw new Error('No earthquake data available');
                }
                
                earthquakes = data.features.map(feature => ({
                    magnitude: feature.properties.mag || 0,
                    location: feature.properties.place || 'Unknown',
                    time: new Date(feature.properties.time),
                    coordinates: feature.geometry.coordinates,
                    depth: feature.geometry.coordinates[2] || 0,
                    // Add additional properties for better information
                    type: feature.properties.type,
                    status: feature.properties.status,
                    tsunami: feature.properties.tsunami,
                    sig: feature.properties.sig // significance
                }));

                // Sort by time (newest first)
                earthquakes.sort((a, b) => b.time - a.time);
                
                console.log(`Loaded ${earthquakes.length} earthquakes from live data`);
                updateStatistics();
                loading.style.display = 'none';
                startAnimation();
                
            } catch (error) {
                console.error('Error fetching earthquake data:', error);
                
                // Try alternative API endpoint
                try {
                    const response = await fetch('https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/4.5_day.geojson');
                    const data = await response.json();
                    
                    if (data.features && data.features.length > 0) {
                        earthquakes = data.features.map(feature => ({
                            magnitude: feature.properties.mag || 0,
                            location: feature.properties.place || 'Unknown',
                            time: new Date(feature.properties.time),
                            coordinates: feature.geometry.coordinates,
                            depth: feature.geometry.coordinates[2] || 0,
                            type: feature.properties.type,
                            status: feature.properties.status,
                            tsunami: feature.properties.tsunami,
                            sig: feature.properties.sig
                        }));
                        
                        earthquakes.sort((a, b) => b.time - a.time);
                        console.log(`Loaded ${earthquakes.length} significant earthquakes (4.5+) from live data`);
                        updateStatistics();
                        loading.style.display = 'none';
                        startAnimation();
                    } else {
                        throw new Error('No data from alternative endpoint');
                    }
                } catch (altError) {
                    console.error('Alternative API also failed:', altError);
                    // Only use demo data as last resort
                    generateDemoData();
                    loading.style.display = 'none';
                    startAnimation();
                }
            }
        }

        // Generate demo data if API fails
        function generateDemoData() {
            console.warn('Using demo data due to API failure');
            earthquakes = [];
            // Create more realistic demo data
            const demoLocations = [
                'San Francisco Bay area, California',
                'Tokyo, Japan',
                'Ring of Fire, Pacific Ocean',
                'Chile Coast',
                'Indonesia',
                'Alaska Peninsula',
                'Mediterranean Sea',
                'New Zealand'
            ];
            
            for (let i = 0; i < 30; i++) {
                earthquakes.push({
                    magnitude: Math.random() * 5 + 2, // 2.0 to 7.0
                    location: demoLocations[Math.floor(Math.random() * demoLocations.length)],
                    time: new Date(Date.now() - Math.random() * 86400000),
                    coordinates: [
                        (Math.random() - 0.5) * 360,
                        (Math.random() - 0.5) * 180,
                        Math.random() * 100
                    ],
                    depth: Math.random() * 100,
                    type: 'earthquake',
                    status: 'demo',
                    tsunami: 0,
                    sig: Math.random() * 1000
                });
            }
            updateStatistics();
            
            // Show warning that demo data is being used
            const demoWarning = document.createElement('div');
            demoWarning.style.cssText = `
                position: fixed;
                top: 80px;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(255, 100, 0, 0.8);
                color: white;
                padding: 10px 20px;
                border-radius: 5px;
                font-size: 14px;
                z-index: 1000;
            `;
            demoWarning.textContent = 'Using demo data - Live API unavailable';
            document.body.appendChild(demoWarning);
            setTimeout(() => demoWarning.remove(), 5000);
        }

        // Update statistics panel
        function updateStatistics() {
            const totalCount = earthquakes.length;
            const strongestMag = Math.max(...earthquakes.map(eq => eq.magnitude)).toFixed(1);
            const latestEq = earthquakes.sort((a, b) => b.time - a.time)[0];
            const latestLocation = latestEq ? latestEq.location : 'Unknown';
            
            document.getElementById('totalCount').textContent = totalCount;
            document.getElementById('strongestMag').textContent = strongestMag;
            document.getElementById('latestLocation').textContent = latestLocation;
            document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString();
        }

        // Get color based on magnitude
        function getMagnitudeColor(magnitude) {
            if (magnitude < 2.5) return '#90EE90';
            if (magnitude < 4.5) return '#FFD700';
            if (magnitude < 6.0) return '#FFA500';
            if (magnitude < 7.0) return '#FF6347';
            return '#FF0000';
        }

        // Artistic visualization mode - Improve centering
        function drawArtisticMode() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#0c0c0c';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Get proper dimensions accounting for device pixel ratio
            const dpr = window.devicePixelRatio || 1;
            const actualWidth = canvas.width / dpr;
            const actualHeight = canvas.height / dpr;
            
            // Ensure we're using the correct center point
            const centerX = actualWidth / 2;
            const centerY = actualHeight / 2;
            
            // Reset hovered earthquake
            hoveredEarthquake = null;
            
            // Draw simple grid
            ctx.strokeStyle = 'rgba(50, 70, 100, 0.15)';
            ctx.lineWidth = 0.5;
            const gridSize = 50;
            
            for (let x = 0; x < actualWidth; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, actualHeight);
                ctx.stroke();
            }
            
            for (let y = 0; y < actualHeight; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(actualWidth, y);
                ctx.stroke();
            }
            
            // Add central glow for better visual focus
            const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.min(actualWidth, actualHeight) * 0.4);
            gradient.addColorStop(0, 'rgba(30, 60, 100, 0.2)');
            gradient.addColorStop(1, 'transparent');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, actualWidth, actualHeight);
            
            // Draw earthquakes in a circular pattern
            earthquakes.forEach((eq, index) => {
                // Basic orbit calculation with better spacing
                const angle = (time * 0.0008 + index * 0.2) % (Math.PI * 2);
                const radius = Math.min(actualWidth, actualHeight) * 0.25 + eq.magnitude * 8;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                const size = eq.magnitude * 2 + 3;
                
                // Check if mouse is hovering
                const distance = Math.sqrt(Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2));
                const isHovered = distance < size * 2;
                
                if (isHovered) {
                    hoveredEarthquake = { eq, x, y };
                    canvas.style.cursor = 'pointer';
                }
                
                // Get color based on magnitude
                const color = getMagnitudeColor(eq.magnitude);
                
                // Draw simple outer glow
                ctx.globalAlpha = 0.3;
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(x, y, size * 2, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw main circle
                ctx.globalAlpha = 1;
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw simple highlight
                ctx.fillStyle = 'white';
                ctx.globalAlpha = 0.5;
                ctx.beginPath();
                ctx.arc(x, y, size * 0.3, 0, Math.PI * 2);
                ctx.fill();
                
                // Reset alpha
                ctx.globalAlpha = 1;
                
                // Add simple connecting lines
                if (index > 0) {
                    const prevEq = earthquakes[index - 1];
                    const prevAngle = (time * 0.0008 + (index - 1) * 0.2) % (Math.PI * 2);
                    const prevRadius = Math.min(actualWidth, actualHeight) * 0.25 + prevEq.magnitude * 8;
                    const prevX = centerX + Math.cos(prevAngle) * prevRadius;
                    const prevY = centerY + Math.sin(prevAngle) * prevRadius;
                    
                    ctx.strokeStyle = 'rgba(100, 180, 220, 0.2)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(prevX, prevY);
                    ctx.stroke();
                }
                
                // Add a simple particle effect occasionally
                if (Math.random() < 0.02 * (eq.magnitude / 5)) {
                    particles.push(new Particle(x, y, eq.magnitude));
                }
            });
            
            // Draw particles
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update();
                particles[i].draw();
                
                if (particles[i].life <= 0) {
                    particles.splice(i, 1);
                }
            }
            
            // Draw tooltip for hovered earthquake
            if (hoveredEarthquake) {
                const { eq, x, y } = hoveredEarthquake;
                
                // Simple tooltip
                const tooltipWidth = 180;
                const tooltipHeight = 90;
                
                // Position above dot
                let tooltipX = x - tooltipWidth / 2;
                let tooltipY = y - tooltipHeight - 10;
                
                // Adjust if needed
                if (tooltipY < 10) tooltipY = y + 10;
                if (tooltipX < 10) tooltipX = 10;
                if (tooltipX + tooltipWidth > actualWidth - 10) {
                    tooltipX = actualWidth - tooltipWidth - 10;
                }
                
                // Draw black box
                ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
                ctx.fillRect(tooltipX, tooltipY, tooltipWidth, tooltipHeight);
                
                // Draw border
                ctx.strokeStyle = getMagnitudeColor(eq.magnitude);
                ctx.lineWidth = 2;
                ctx.strokeRect(tooltipX, tooltipY, tooltipWidth, tooltipHeight);
                
                // Simplify text content
                const shortLoc = eq.location.length > 20 ? eq.location.substring(0, 17) + "..." : eq.location;
                
                // Draw text
                ctx.font = "bold 14px Arial";
                ctx.fillStyle = getMagnitudeColor(eq.magnitude);
                ctx.textAlign = "left";
                ctx.fillText(`Magnitude: ${eq.magnitude.toFixed(1)}`, tooltipX + 10, tooltipY + 20);
                
                ctx.font = "12px Arial";
                ctx.fillStyle = "#ffffff";
                ctx.fillText(`Location: ${shortLoc}`, tooltipX + 10, tooltipY + 40);
                ctx.fillText(`Depth: ${eq.depth.toFixed(1)} km`, tooltipX + 10, tooltipY + 60);
                ctx.fillText(eq.time.toLocaleDateString(), tooltipX + 10, tooltipY + 75);
                
                // Draw simple connecting line
                ctx.beginPath();
                ctx.strokeStyle = getMagnitudeColor(eq.magnitude);
                ctx.lineWidth = 1;
                
                if (tooltipY > y) {
                    ctx.moveTo(x, y + 3);
                    ctx.lineTo(x, tooltipY);
                } else {
                    ctx.moveTo(x, y - 3);
                    ctx.lineTo(x, tooltipY + tooltipHeight);
                }
                
                ctx.stroke();
            }
            
            // Reset cursor if not hovering
            if (!hoveredEarthquake) {
                canvas.style.cursor = 'default';
            }
        }

        // Geographic visualization mode
        function drawGeographicMode() {
            // Get actual canvas dimensions (accounting for device pixel ratio)
            const dpr = window.devicePixelRatio || 1;
            const actualWidth = canvas.width / dpr;
            const actualHeight = canvas.height / dpr;
            
            // Clear canvas completely with sharp rendering
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.restore();
            
            ctx.fillStyle = '#0c0c0c';
            ctx.fillRect(0, 0, actualWidth, actualHeight);

            const centerX = actualWidth / 2;
            const centerY = actualHeight / 2;
            const mapWidth = Math.min(actualWidth * 0.8, 800);
            const mapHeight = mapWidth * 0.5;
            
            // Draw map border with better visibility
            ctx.strokeStyle = 'rgba(140, 160, 200, 0.6)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.rect(centerX - mapWidth/2, centerY - mapHeight/2, mapWidth, mapHeight);
            ctx.stroke();
            
            // Add subtle ocean fill for contrast
            ctx.fillStyle = 'rgba(20, 40, 80, 0.1)';
            ctx.fillRect(centerX - mapWidth/2, centerY - mapHeight/2, mapWidth, mapHeight);
            
            // Draw grid lines
            ctx.strokeStyle = 'rgba(100, 120, 180, 0.3)';
            ctx.lineWidth = 0.8;
            
            // Draw longitude lines (every 30 degrees)
            for (let lon = -180; lon <= 180; lon += 30) {
                const x = centerX + (lon * mapWidth / 360);
                ctx.beginPath();
                ctx.moveTo(x, centerY - mapHeight/2);
                ctx.lineTo(x, centerY + mapHeight/2);
                ctx.stroke();
                
                // Add longitude labels with better visibility
                if (lon !== 0) {
                    ctx.fillStyle = 'rgba(200, 200, 255, 0.8)';
                    ctx.font = 'bold 10px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(`${Math.abs(lon)}°${lon < 0 ? 'W' : 'E'}`, x, centerY + mapHeight/2 + 15);
                }
            }
            
            // Draw latitude lines (every 30 degrees)
            for (let lat = -60; lat <= 60; lat += 30) {
                const y = centerY + (lat * mapHeight / 180);
                ctx.beginPath();
                ctx.moveTo(centerX - mapWidth/2, y);
                ctx.lineTo(centerX + mapWidth/2, y);
                ctx.stroke();
                
                // Add latitude labels with better visibility
                if (lat !== 0) {
                    ctx.fillStyle = 'rgba(200, 200, 255, 0.8)';
                    ctx.font = 'bold 10px Arial';
                    ctx.textAlign = 'right';
                    ctx.fillText(`${Math.abs(lat)}°${lat < 0 ? 'S' : 'N'}`, centerX - mapWidth/2 - 5, y + 4);
                }
            }
            
            // Draw equator and prime meridian with different color for emphasis
            ctx.strokeStyle = 'rgba(120, 180, 255, 0.8)';
            ctx.lineWidth = 1.5;
            
            // Equator
            ctx.beginPath();
            ctx.moveTo(centerX - mapWidth/2, centerY);
            ctx.lineTo(centerX + mapWidth/2, centerY);
            ctx.stroke();
            
            // Prime meridian
            ctx.beginPath();
            ctx.moveTo(centerX, centerY - mapHeight/2);
            ctx.lineTo(centerX, centerY + mapHeight/2);
            ctx.stroke();
            
            // Add labels for equator and prime meridian with better visibility
            ctx.fillStyle = 'rgba(180, 220, 255, 0.9)';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Equator', centerX + mapWidth/2 + 40, centerY + 4);
            ctx.fillText('Prime Meridian', centerX, centerY - mapHeight/2 - 10);

            // Reset hovered earthquake
            hoveredEarthquake = null;

            // Draw earthquake points with better visual impact
            earthquakes.forEach(eq => {
                // Convert coordinates: longitude (-180 to 180), latitude (-90 to 90)
                const longitude = eq.coordinates[0];
                const latitude = eq.coordinates[1];
                
                // Calculate position on map
                const x = centerX + (longitude * mapWidth / 360);
                const y = centerY - (latitude * mapHeight / 180); // Flip latitude
                
                // Check if point is within map bounds
                if (x >= centerX - mapWidth/2 && x <= centerX + mapWidth/2 && 
                    y >= centerY - mapHeight/2 && y <= centerY + mapHeight/2) {
                    
                    const size = eq.magnitude * 2.5 + 2;
                    
                    // Check if mouse is hovering over this earthquake
                    const distance = Math.sqrt(Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2));
                    const isHovered = distance < size * 2;
                    
                    if (isHovered) {
                        hoveredEarthquake = { eq, x, y };
                        canvas.style.cursor = 'pointer';
                    }
                    
                    // Add pulsing effect
                    const pulse = Math.sin(time * 0.02 + eq.magnitude) * 0.3 + 0.7;
                    
                    // Draw earthquake point
                    ctx.save();
                    
                    // Outer glow for better visibility (larger if hovered)
                    const gradient = ctx.createRadialGradient(x, y, 0, x, y, size * (isHovered ? 3 : 2));
                    gradient.addColorStop(0, getMagnitudeColor(eq.magnitude));
                    gradient.addColorStop(1, 'transparent');
                    ctx.globalAlpha = (isHovered ? 0.6 : 0.4) * pulse;
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(x, y, size * (isHovered ? 3 : 2), 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Core with higher contrast
                    ctx.globalAlpha = 0.9 * pulse;
                    ctx.fillStyle = getMagnitudeColor(eq.magnitude);
                    ctx.beginPath();
                    ctx.arc(x, y, size * (isHovered ? 1.5 : 1), 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Add bright inner dot for focus
                    ctx.globalAlpha = 0.7;
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(x, y, size * 0.3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                }
            });
            
            // Reset cursor if not hovering
            if (!hoveredEarthquake) {
                canvas.style.cursor = 'default';
            } else {
                // Draw tooltip - simplified approach
                const { eq, x, y } = hoveredEarthquake;
                
                // Tooltip styling
                const tooltipWidth = 200;
                const tooltipHeight = 100;
                const padding = 10;
                
                // Position above earthquake dot
                let tooltipX = x - tooltipWidth / 2;
                let tooltipY = y - tooltipHeight - 10;
                
                // If too close to top, put below
                if (tooltipY < 10) {
                    tooltipY = y + 10;
                }
                
                // Keep in bounds
                if (tooltipX < 10) tooltipX = 10;
                if (tooltipX + tooltipWidth > actualWidth - 10) {
                    tooltipX = actualWidth - tooltipWidth - 10;
                }
                
                // Draw black background box
                ctx.fillStyle = "rgba(0, 0, 0, 0.9)";
                ctx.fillRect(tooltipX, tooltipY, tooltipWidth, tooltipHeight);
                
                // Draw border
                ctx.strokeStyle = getMagnitudeColor(eq.magnitude);
                ctx.lineWidth = 2;
                ctx.strokeRect(tooltipX, tooltipY, tooltipWidth, tooltipHeight);
                
                // Prepare text content
                const shortLoc = eq.location.length > 25 ? eq.location.substring(0, 22) + "..." : eq.location;
                const shortDate = eq.time.toLocaleDateString();
                
                // Draw text content
                ctx.font = "bold 14px Arial";
                ctx.fillStyle = getMagnitudeColor(eq.magnitude);
                ctx.textAlign = "left";
                ctx.fillText(`Magnitude: ${eq.magnitude.toFixed(1)}`, tooltipX + padding, tooltipY + padding + 12);
                
                ctx.font = "12px Arial";
                ctx.fillStyle = "#ffffff";
                ctx.fillText(`Location: ${shortLoc}`, tooltipX + padding, tooltipY + padding + 35);
                ctx.fillText(`Depth: ${eq.depth.toFixed(1)} km`, tooltipX + padding, tooltipY + padding + 55);
                ctx.fillText(`Date: ${shortDate}`, tooltipX + padding, tooltipY + padding + 75);
                
                // Draw connecting line
                ctx.beginPath();
                ctx.strokeStyle = getMagnitudeColor(eq.magnitude);
                ctx.lineWidth = 1.5;
                
                if (tooltipY > y) {
                    // Line from point to tooltip (tooltip is below)
                    ctx.moveTo(x, y + 5);
                    ctx.lineTo(x, tooltipY);
                } else {
                    // Line from point to tooltip (tooltip is above)
                    ctx.moveTo(x, y - 5);
                    ctx.lineTo(x, tooltipY + tooltipHeight);
                }
                
                ctx.stroke();
            }
        }

        // Animation loop
        function animate() {
            time++;
            
            // Draw based on current mode (removed timeline option)
            if (currentMode === 'artistic') {
                drawArtisticMode();
            } else if (currentMode === 'geographic') {
                drawGeographicMode();
            }
            
            // Continue animation
            animationId = requestAnimationFrame(animate);
        }

        function startAnimation() {
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            animate();
        }

        // Control functions
        function setVisualizationMode(mode) {
            currentMode = mode;
            document.querySelectorAll('.control-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            particles = [];
            // Clear particles when switching modes
            // Reset time to restart animations smoothly
            time = 0;
        }

        // Initialize
        fetchEarthquakeData();
        
        // Auto-refresh data every 5 minutes
        setInterval(() => {
            fetchEarthquakeData();
        }, 300000);
    </script>
</body>
</html>